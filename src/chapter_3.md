# 第三章 - 通用编程概念

Rust中定义了一些关键字，大部分关键字有特殊的含义，你不能将它们作为变量名或者函数名

- `as` - 执行基本类型转换，消除某个类型的项的特定特质的歧义，`use`语句中重命名项
  - 基本类型转换仅支持基本类型，包含数字类型、布尔、字符以及裸指针
  - 消除歧义是指当一个项的类型实现了多项特质，这些特质中提供了同名方法，调用时可以使用`<Type as Trait>::some_method()`
- `async` - 返回一个`Future`而不是阻塞当前线程
- `await` - 终止执行，直到`Future`的结果准备好
- `break` - 立即退出循环
- `const` - 定义常量或者常量裸指针
- `continue` - 进入下一次循环
- `crate` - 在模块路径中，引用crate根
- `dyn` - 动态分配到一个特质对象
- `else` - `if`或者`if let`控制流结构的相反条件块
- `enum` - 定义一个枚举
- `extern` - 链接一个外部函数或者变量
- `false` - 表示布尔类型的`false`
- `fn` - 定义一个函数或者函数指针类型
- `for` - 从一个迭代器遍历项，为类型实现一个特质，指定一个更高阶的生命周期
  - 高阶生命周期（Higher-Ranked Trait Bounds, HRTB），即允许泛型生命周期参数被「任意生命周期」满足
- `if` - 基于条件表达式的结果的分支
- `impl` - 实现自身功能或者特质的功能
- `in` - `for`循环语法的一部分
- `let` - 绑定一个变量
- `loop` - 无条件循环
- `match` - 将值与模式进行匹配
- `mod` - 定义一个模块
- `move` - 让闭包拿到它捕获内容的所有权
- `mut` - 在引用、裸指针或者模式绑定中表示可变性
- `pub` - 在结构体成员、impl块中或者模块里表示公共可见性
- `ref` - 通过引用绑定
- `return` - 从函数返回
- `Self` - 我们定义或者实现的类型的一个表示自己的别名
- `self` - 方法的主体，模块树中表示当前模块
- `static` - 全局变量，持续到整个程序执行期间的生命周期
- `struct` - 定义一个结构体
- `super` - 当前模块的父模块
- `trait` - 定义一个特质
- `true` - 布尔值类型的true
- `type` - 定义一个类型别名或者关联类型
- `union` - 定义一个联合体，只有在`union`声明中才是关键字
- `unsafe` - 表示不安全代码，函数，特质或者特质的实现代码
- `use` - 将符号（symbols）引入域
- `where` - 表示限制类型的特质的语句
- `while` - 基于一个表达式的结果的条件循环

*Raw identifiers*（`r#`）允许你使用任何单词作为标识符，使用时也需要加上`r#`。如果*Rust Edition*指定为老版本中的代码中还不是关键字的标识符要在新版本使用，也需要加上`r#`

## 变量和可变性

**默认变量都是不可变的（*immutable*）**，这是Rust让你利用Rust提供的安全性和依靠简单并发的方式写代码的引导方式之一。如果代码中一部分认为某个值是不可变的而另一部分认为是可变的，那么前一部分代码很可能由于另一部分代码修改值导致无法正常工作。Rust编译器会保证当你声明一个值不会改变，它就不会被改变

将`mut`关键字放到变量名前面可以使变量为可变的，所以决定是否使用可变变量取决于你自己，依赖特定情况下代码如何表达能更清晰

### 常量

常量是绑定到一个名字的值，并且**不可变**，但是和变量有一些区别

- 首先常量不能使用`mut`关键字修饰，使用`const`而不是`let`来声明，值的类型必须被**注解**（*annotated*）
- 常量可以在任意域中声明，包括全局范围，那些需要在代码多个地方使用的不变值更适合使用常量声明
- 常量只能绑定常量表达式，不能是在运行时才被计算出来的值

Rust中常量命名习惯为**全大写+下划线分隔符**。编译器在编译期可以执行计算一些操作，查看[Rust Reference's section on constant evaluation](https://doc.rust-lang.org/reference/const_eval.html)寻找更多声明常量支持的操作。将程序中到处使用的硬编码值命名为常量也能向代码未来的维护者传达准确的含义，并且在未来如果需要更新这个值，只需要修改一次即可

### 覆盖操作

实际上在覆盖操作中，第二个变量声明会覆盖第一个，直到它自己被覆盖，或者域结束之前它将所有对这个变量名的使用都指向了自己。通过使用`let`，我么可以让某个变量经过一系列的转换之后仍然是不可变的。因为我们使用`let`创建了新的变量，所以我们可以改变同名变量的类型

## 数据类型

Rust中每个值都有确定的数据类型，类型信息告诉Rust数据是什么结构，它会知道数据该如何处理。Rust中存在两种类型子集：scalar（标量）、compound（复合类型）。Rust是静态类型语言，编译期必须知道所有变量的类型。基于值和代码的使用方式，编译器通常可以推断出我们想使用的类型，一旦有多种类型都有可能时（比如将字符串转换为数字），就需要添加类型注解

### 标量类型

**标量类型**（*scalar*）表示单个值，Rust有四种主要的标量类型，整数、浮点数、boolean、字符

#### 整数类型

整数是没有小数部分的数字。Rust的内置整数类型有8、16、32、64、128位长度以及和CPU架构大小相等的6种类型，都分有符号和无符号数字，大小确定。有符号数以二进制补码形式存储。`isize`和`usize`的类型取决于程序运行的计算机CPU架构，如果是64bit就是64，32bit就是32

下表是整数不同进制表示的字面值形式。数字字面值后面可以加类型后缀，例如`57u8`

|Number Literals |Example|
|--|--|
|Decimal |98_222|
|Hex |0xff|
|Octal |0o77|
|Binary |0b1111_0000|
|Byte(u8) |b'A'|

##### 整数溢出

出现整数溢出后，如果程序是debug模式编译，会触发panic退出程序。如果使用`--release`参数编译代码，Rust会进行二进制补码`wrapping`计算，简单说就是超过最大值的话就从该类型的最小值*wrap around*。要在程序中处理溢出，可以使用标准库为主要的数字类型提供的以下方法

- `wrapping_*`方法来进行wrap计算，任何编译模式下都进行wrap
- 如果溢出则返回`None`，使用`checked_*`方法
- 返回wrap值和一个标识来告知是否越界，使用`overflowing_*`方法
- 变为同类型的最大/最小值，使用`saturating_*`方法，超出最大值就是最大值，低于最小值就是最小值

#### 浮点类型

Rust有两种主要的浮点数类型`f32`和`f64`，分别表示32位和64位浮点数，默认类型是`f64`，因为现代CPU的计算速度对于两者差不多，但是后者精度更高，所有的浮点类型都是**有符号的**

浮点数实现为IEEE-754标准

#### 数字操作

Rust提供了数字之间的加、减、乘、除、取余操作。整数除法是向下取值。其它操作符参考[Operators](https://doc.rust-lang.org/book/appendix-02-operators.html)

#### 布尔类型

Rust中布尔类型有两个值`true`和`false`，布尔值占用**1个字节**。使用`bool`来指定布尔类型。布尔类型的主要用法是在条件判断中，例如`if`表达式

#### 字符类型

Rust的`char`类型是语言中最主要的字母类型，使用**单引号**来指定`char`字面值。`char`类型**4个字节**大小，表示一个Unicode Scalar Value，即它表示比ASCII更多的内容。Unicode标量范围从U+0000到U+D7FF和U+E000到U+10FFFF。一个`char`的值在Unicode中只是一个码点，而不一定对应一个人类感知的“字符”或“字素簇”

### 复合类型

复合类型是将多个值组织成为一个类型

#### 元组类型

一个元组是将不同类型的几个值放到一起组成的一种复合类型，元组有固定长度，**声明后不能扩大或缩小容量**

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
```

通过`let`结合模式来分别获取元组值中单独的值，这叫做**解构**（*destructuring*）。还可以使用`.`跟上要访问的值的索引来访问元素。不包含值的元组有特殊的名字，叫做*unit*。这个值写作`()`，表示空元组或者空返回类型。不返回任何其它值的表达式实际上隐式返回了`()`

#### 数组类型

**数组中每个元素的类型必须相同**。Rust中数组的长度是固定的

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

当你想将数据分配在栈上，就像之前看到的其它基本类型，而不是在堆上时，或者你想保证你总是有固定数量的元素时，应该使用数组。数组在不会改变元素数量的时候很有用，例如十二个月的英文名称`let a: [i32; 5] = [1, 2, 3, 4, 5];`，`i32`是每个元素的类型，分号后是数组的大小。使用一定数量的相同元素初始化数组`let a = [3; 5];`

##### 访问数组元素

一个数组是分配在栈上的已知、固定大小的一块内存，通过索引语法可以访问其中的元素

##### 无效的数组元素访问

数组越界访问会导致一个运行时错误，程序会打印错误信息然后退出，这种情况只会发生在运行时

## 函数

Rust的函数命名风格为*snake case*，即全小写单词+下划线分隔符。Rust不关心在哪里定义函数，只要它们定义的位置，调用者在当前域中可见即可调用

### 参数

参数是属于**函数签名**的一部分的特殊变量。声明的参数称为*parameter*，实际传入的值为*argument*。在函数签名中，必须声明每个参数的类型，这是Rust刻意的设计：在函数定义中需要类型注解意味着编译器不需要在代码的其它位置使用它们时知道需要什么类型，并且知道参数类型编译器也能给出更多有帮助的错误信息

### 语句和表达式

函数体是由一组语句（可选）和一个结尾的表达式（ending expression）构成。**Rust是基于表达式的语言**

- *statements*：执行动作的指令，不返回值
- *expressions*：通过计算得到的结果值

函数的定义本身也是语句，调用函数的结果是表达式，表达式可以是语句的一部分，**调用一个宏也是表达式**，使用一组花括号创建的一个新范围块也是一个表达式。表达式不包含结尾的分号，如果在表达式后面加上分号，那么它就变成了语句，不会返回值

### 有返回值的函数

函数可以向调用它们的代码返回值，返回值可以不命名，但是必须在`->`后声明它们的类型，返回值的类型也是函数签名的一部分，Rust中函数的返回值就是函数体中最后一个表达式。你可以使用`return`提前返回一个值，但是大多数函数隐式返回函数体最后一个表达式

## 注释

Rust中惯常的注释风格是`//`后跟注释内容，注释持续到行尾，如果注释超过一行，那么每一行都需要`//`开头。通常注释写在被注解的代码上单独一行而不是在代码后（这样写也合法）

## 控制流

### `if`表达式

`if`表达式可以根据条件来对代码创建分支。所有的`if`表达式开头都是`if`关键字。`if`表达式的条件所关联的代码块有时也叫分支

`else`表达式所关联的代码是程序在条件表达式计算为`false`时执行的。如果不提供`else`表达式，那么程序会跳过`if`语句块执行下面的代码。`if`的条件表达式类型必须为`bool`，如果条件不是`bool`，编译器会报错

### 使用`else if`来处理多个条件

你可以通过组合`if`和`else`以及`else if`表达式来判断多个条件。要注意Rust只会执行第一个条件表达式结果为`true`时所关联的代码块，之后不会再检查其它的条件

使用太多的`else if`可能会弄乱你的代码，这种情况下你应该考虑重构你的代码

### 在`let`语句中使用`if`

因为`if`是一个表达式，我们可以在`let`语句的右边将它的计算结果赋值给变量

```rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {number}");
}
```

编译上面这段代码会报错，因为`if`表达式和`else`表达式返回值的类型不同。因为变量只能有一个类型，Rust需要在编译期知道这个变量类型是什么，这会让我们在其它地方使用这个变量时，编译器能确定变量类型是有效的

### 使用循环

#### `loop`

`loop`关键字告诉Rust需要一直执行代码块，直到显式退出。在循环中使用`break`关键字跳出循环。使用`continue`关键字跳过循环中剩余部分代码而直接进入下一次循环

##### 从循环中返回值

`loop`的一个用法是可以重试你知道可能会失败的操作，例如检查线程是否已经完成工作。你可能需要将操作结果返回给循环外的其它代码，你可以在`break`表达式后加上你想返回的值

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {result}");
}
```

##### 在多重循环中使用Loop Labels来消除歧义

如果存在多个嵌套的`loop`，`break`和`continue`都只应用于它们所处的最内层的循环，可以通过指定**loop label**来直接结束/或跳转到指定的循环，标记必须以单引号开头`'loop_label:`

```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

#### 使用`while`进行条件循环

程序经常需要在循环中计算一个条件表达式。当结果为`true`循环运行，当条件为`false`，程序使用`break`停止循环，这就是`while`关键字的循环模式，要计算的条件表达式放在`while`之后

#### 使用`for`来遍历集合

使用`while`加索引的方式也可以遍历集合元素，但是如果索引值错误或者测试条件有问题，这种方法就很容易出错，而且这种方式也很慢，因为编译器加了运行时代码在每次循环中执行索引是否处于数组的界限的检查

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

`for`循环的安全性和简单性让它成为Rust中最常用的循环结构，利用标准库提供的`Range`结构，那些需要执行固定次数代码也都使用`for`循环
