# 并发编程

本章目标是给你一个异步并发工作方式和它与线程并发的区别的思路。在进入练习前有一个好的心理模型是很重要的

用户想让他们的计算机做很多事。有时用户想同时做很多事。有时同一时间做很多事效率很高，有时同时有很多人想使用一台计算机（连接到一个服务器的很多客户端）

例如，一个音乐程序可能需要在用户和UI交互时播放音乐。要“保持播放音乐”，可能需要从服务器保存音乐数据流，转换数据格式，将处理好的数据通过OS发送到计算机的音频系统。对于用户来说，可能需要根据用户指令向服务器收发数据或命令，可能需要向播放音乐子系统发送信号（例如换歌或者暂停），可能需要更新图形展示（高亮按钮或者改变歌曲名称），必须保持鼠标光标或者文本输出在做上面这些事的时候都是可响应的

同时做很多事叫做并发。程序（和OS）必须管理它们的并发度，有很多方法可以做到

## 顺序执行

大多数程序语言中默认的执行方式是顺序执行

```rust
do_a_thing();
println!("hello!");
do_another_thing();
```

每条语句在执行下一条之前完成。在语句中间没有其它事情发生。这对于理解我们的代码是很有用的属性，但是这也意味着我们浪费了大量时间。上面的代码中，当我们等待打印时，我们可以执行`do_another_thing()`，或许我们可以同时执行这三条语句

当IO发生时（打印是IO，它将文本输出到控制台，通过OS的调用），程序要等待IO完成，再执行下一条语句。在继续执行前等待IO完成会**阻塞**程序做其它事情。阻塞IO（Blocking IO）是最简单的一种IO，但它也是效率最低的。在顺序世界中，程序除了等待IO完成什么都干不了

## 进程和线程

进程和线程是操作系统提供并发能力的概念。每个可执行程序有一个进程，所以支持多进程的计算机可以并发运行多个程序，每个进程可以有多个线程，这意味着进程内也可以并发。进程和线程的处理方式有很多小的区别。最重要的区别是线程共享内存，但进程不共享。这意味着进程之间的通信需要某种消息传递的方式，类似于不同计算机程序之间的通信。在程序视角，单个线程就是全世界，创建一个新进程就是运行了一个新程序。然而创建一个新线程只是程序执行的一部分

因为进程和线程之间的区别，对于程序员来说感觉很不一样。但是从OS的视角看它们很相似，我们讨论它们的属性就像它们是一回事一样

OS负责排布线程，决定线程什么时候运行、运行多久。大多数现代计算机有多个核心，所以它们可以同时运行多个线程。然而线程数超过核心数很常见，所以OS会每个线程运行一小段时间，然后暂停运行不同的线程。当多个线程以这种方式运行在一个核心上时，叫做交错（interleaving）或者时间片（time-slicing）。因为OS选择什么时候暂停线程执行，这叫做抢占式多任务（pre-emptive multitasking）（这里的多任务是同时运行的多个线程）。OS抢占式执行一个线程（更详细地说是OS抢占式地暂停了执行。之所以是抢占式，是因为OS会暂停一个线程为另一个线程运行争取时间，这是在第一个线程自然暂停之前发生的，为了保证第二个线程不因为不能运行成为问题

当一个线程在阻塞等待IO时会发生什么？在使用线程的系统中，OS会暂停线程，然后当IO完成时再唤醒它。根据排布算法的不同，在IO处理完成到OS唤醒线程之间还会花费一些时间，因为OS可能会等待其它线程工作结束。现在很高效：尽管一个线程在等待IO，另一个线程（可能是很多线程）仍然可以执行。但是从处理IO的线程的视角来看，事情还是顺序发生的--在下一个操作前必须等待IO完成

线程可以选择使用`sleep`函数来暂停自己，通常会有一个超时。这种情况下，OS会暂停线程在它请求的地方。和由于抢占式执行或者IO所造成的暂停类似，OS会在超时之后唤醒线程继续执行

当OS暂停一个线程然后开始另一个，这个过程叫做上下文切换。被切换的上下文包括寄存器、操作系统记录、很多缓存信息。这不是一个简单的工作。还有将控制权还给OS和之后再还回线程，处理失效缓存的工作，上下文切换是一项昂贵的操作

还要注意的是一些硬件或者OS不支持进程或者线程，主要包括大部分嵌入式设备

## 异步编程

异步编程是一种并发，在作为并发的高级目标上和线程是一致的，但是实现不同。和线程相比有两个非常大的不同，异步并发完全在程序内管理，而不需要OS的帮助，多任务是合作性质而不是抢占式。异步并发有很多不同的模型

为了和线程做出区分，我们称在异步并发中的执行序列叫做任务（它们也叫做绿色线程，但是有时这个名称带有抢占式排布和每个任务一个栈的实现细节）。任务执行、排布和内存中的表示的方式都和线程有很大区别。但是在高级的直觉上，将任务看作线程是很有用的，只是它们由程序管理而不是OS

在一个异步系统中，还有一个决定之后运行哪个任务的排布器（程序的一部分，而不是OS的一部分）。然而这个排布器不能抢占一个任务。任务必须自愿放弃它的控制权，然后让其它任务去被排布。因为任务必须合作，所以这叫做协同式多任务（cooperative multitasking

使用协同式而非抢占式有很多含义

* 在控制权被给出的点之间，你可以保证代码会顺序执行，即你不会被意外暂停
* 如果在给出控制权的点之间的任务花费了很长时间，其它任务不会被执行
* 实现一个排布器很简单，排布的消耗也很小

异步并发要比线程的效率高。内存占用也更低，上下文切换是更便宜的操作，它不需要处理将控制权给OS然后再还回给程序，要切换的数据也更少。然而还是会有一些缓存影响，尽管OS的缓存，例如TLB，不需要改变，任务可能会操作内存的不同部分，所以新被排布的任务所需要的数据可能不在内存缓存中

异步IO是阻塞IO的替代品。异步IO并不直接和异步并发有关系，但是两者经常一起使用。在异步IO中，一个程序通过一个系统调用发起IO，然后当IO完成可以检查或者被通知。这意味着程序在IO发生的时候可以做其他事情。Rust中，异步IO的机制通过异步运行时来处理（排布器也是运行时的一部分）

从整个系统的视角看，在线程并发系统中的阻塞IO和非阻塞IO异步编程系统中的非阻塞IO相似，两种情况中IO得到运行时间，在IO过程中其他工作可以完成

* 使用线程，IO线程向OS请求IO，这个线程被OS暂停，其它线程工作完成，当IO完成，OS唤醒线程，它可以以IO结果继续执行
* 使用异步，IO任务向运行时请求IO，运行时向OS请求IO但是OS返回控制权给运行时，运行时会暂停IO任务，然后排布其它的任务执行，当IO完成，运行时唤醒IO任务，可以以IO结果继续执行

使用异步IO的优点是它的开销非常低，所以系统可以支持比线程多出几个数量级的任务。这让异步并发更适合那些有很多用户需要花费大部分时间等待IO的任务（如果它们不会花很长时间等待，而是做很多CPU限制的工作，那么低开销的优势就不大了，因为瓶颈变成了CPU和内存资源）

线程和异步不是互相排斥的：很多程序会同时使用它们。一些程序一部分更适合使用线程实现，另一部分更适合使用异步。例如一个数据库服务器可能使用异步来管理和客户端的网络连接，但是使用OS线程来计算数据。一个程序可能只使用异步并发写，但是运行时会在多个线程上执行任务。对一个程序来说使用多核是必要的

## 并发和并行

并发和并行有时会被互换使用，但它们是完全不同的概念

```text
task1 {
  subTask1-1()
  subTask1-2()
  ...
  subTask1-100()
}
```

假设有一个处理器会执行这些伪代码。执行方式会是顺序执行。现在想象如果有多个任务我们该怎么执行。我们可能会执行一个任务，执行所有的子任务直到整个任务完成，然后开始下一个。这两个任务会顺序执行（子任务也是）

```text
subTask1-1()
subTask1-2()
...
subTask1-100()
subTask2-1()
subTask2-2()
...
subTask2-100()
```

或者，你可以先做第一个任务的第一个子任务，然后将第一个任务放到一边（记住当前进度），然后选下一个任务，做它的第一个子任务，然后再回去做第一个任务应该做的子任务。两个任务可能是交错的

```text
subTask1-1()
subTask2-1()
subTask1-2()
subTask2-2()
...
subTask1-100()
subTask2-100()
```

除非一个任务可以观察结果或者被一个不同的任务影响，否则从一个任务的视角看，子任务仍然是顺序执行的

我们不需要限制在两个任务，我们可以以任意数量交错运行任意数量的任务

注意无论我们增加多少并发度，整个工作完成花费的时间都相同（因为并发度的增加，由于上下文切换导致的开销会花费更长时间），然而对于某个特定的子任务，我们会比完全顺序执行更早得到它的结果（对于用户来说，就是更好的响应性）

现在想象你有一个处理器朋友来帮助你，你可以同时开始处理两个任务，可以更快完成工作。这是一个并行执行（也是并发）

```text
Processor 1           Processor 2
==============        ==============
subTask1-1()          subTask2-1()
subTask1-2()          subTask2-2()
...                   ...
subTask1-100()        subTask2-100()
```

如果有超过两个处理器，我们可以并行处理更多任务。我们也可以在每个处理器交错执行任务或者在处理器之间共享任务

在真实代码中，事情会更复杂，一些子任务（例如IO）不需要处理器参与，它们只需要开始，然后等待时间收集结果。一些子任务可能需要一个不同任务的子任务的结果（side-effects，副作用）来进行（同步）。这些场景限制了任务可以被并发执行的高效方式，结合要保证一些公平性，这就是为什么排布非常重要

## 蠢例子够多了，让我们尝试正确地定义这些事情

Concurrency is about ordering of computations and parallelism is about the mode of execution.

并发关注的是计算的顺序，并行关注的是执行的模式

对于两个计算，如果我们可以观察到一个发生在另一个之前，我们称它们是顺序的，或者如果我们不能观察到这一点（或者它不重要），我们称它们是并发的

如果它们确实是同时发生，那么两个计算就是并行发生。我们可以将并行性看作一种资源：如果有更多的并行性，在固定的一段时间内就会有更多的计算发生（假设计算以相同速度发生）。在不增加并行度的前提下增加系统的并发度永远不会让它更快（尽管可以让系统响应性更好，并且让那些原本不实际的优化变得可行）

两个计算可能一个发生在另一个之后（不是并发也不是并行），它们的执行可能在一个CPU核心上交错（并发），或者它们同时在两个核心上执行（并发和并行）

另一种有用的概念是，并发是一种组织代码的方式，并行是一种资源。这是非常有力的语句。并发是关于组织代码而不是执行代码这一概念非常重要，因为**从处理器角度**，没有并行的并发不存在。这对异步并发尤其重要，因为它们完全在用户端代码实现，它不仅仅关于组织代码，你甚至可以通过阅读源码很轻易地验证这一点。并行性是一种资源也很重要，因为它提醒我们，对于并行和性能，只有处理器核心的数量才是最重要的，而不是代码用什么并发模型来组织（例如有多少线程）

线程和异步系统都可以提供并发性和并行性。两种方式下，并发通过代码控制（spawning线程或者任务），并行通过排布器控制，对于线程来说是OS的一部分（通过OS的API配置），对于异步来说是运行时库的一部分（对运行时的选择控制，运行时是如何实现的，运行时提供给客户端代码的选项）。然而，由于习惯和通常默认的看法，仍然有一个实际的区别。在线程系统中，每个并发线程会使用尽可能多的并行性去并行执行。在异步系统中，没有这一强大的默认惯例：一个系统可能会在一个线程上运行所有任务，它可能会将多个任务分配给一个线程，然后将那个线程锁定到一个核心（所以每组任务是并行运行，但是组内的每个任务是并发执行，但是永远不会和组内其它任务并行执行），或者任务可能有或者没有限制并行运行。对于第一部分我们会使用Tokio运行时，它主要支持后一种模型，即并行行为和使用线程的并发类似。此外我们会看到异步Rust中明确支持并发而不能并行的特性，独立于运行时

## 总结

* 有很多执行模型，我们解释了顺序执行、线程和进程以及异步编程
  * 线程是OS提供（排布）的抽象。它们通常是抢占式多任务，默认并行，相对来说更高的管理开销和上下文切换开销
  * 异步编程是用户空间的运行时管理的。多任务是协作式的。比线程更低的开销，但是和线程的编程方式有些不一样，因为它使用不同的编程原语（async和await、futures而不是第一公民threads）
* 并发和并行是不同但是相关的概念
  * 并发是关于计算的顺序（如果操作执行顺序不能被观察到那么操作是并发的）
  * 并行是关于多核上的计算（如果操作真的是同时发生，那么操作就是并行的）
* OS线程和异步编程提供了并发性和并行性，异步编程也提供了灵活的结构，或者不是大部分操作系统的线程API的细粒度并发性
